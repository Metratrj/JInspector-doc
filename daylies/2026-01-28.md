Architektur Planung
Ich hab mich die Frage gestellt in wie weit ich auf Libraries basiert coden möchte und wie viel ich selber schreibe. 
Die Frage wie etwas umgesetzt wird ist häufig bei mir weniger die Frage.

Vorteile fürs selber schreiben liegen klar auf der Hand:
- Ich lerne den Prozess von Anfang bis Ende.
- Wodurch ich ein tiefes Verständis dafür entwickle was passiert
Nachteile:
- Häufig erstmal Technical dept 
- Zeitaufwändig
- Bedarf dementsprechend auch mehr code der zu pflegen ist


Vorteile auf Libraries sich zu verlassen:
- Sind häufiger erprobt und dadurch auch verlässliger
Nachteil:
- Man muss sich aber auch in die Verwendung der Libs einarbeiten was für die einarbeitung zeit kostet aber im nachhinein mir massiv Zeit ersparnis

Ich werde was die Opcode analyse betrifft größtenteils selber schreiben.
Die Alternative wäre die https://asm.ow2.io/ ASM Lib 
Diese ist anscheinend "quasi Industriestandart" - erhält verwendung in OpenJDK, dem Groovy und Kotlin Kompiler, Cobertura und Jacoco, Byte Buddy, Mockito sowie in Gradle. Man könnte quasi sagen Java Basiert auf dieser Libary.

Aber dieses Projekt ist für mich auch Grund genau dieses Opcode-System zu verstehen und eine eigene Analyse dafür zu schreiben. 

Kommen wir nun aber zur interaktion mit der Software würde ich doch ganz gerne eigentlich ein GUI anbieten. Ein TUI war zwar auch eine überlegung aber das mache ich fast immer. Und ein schickes GUI wäre zu abwechslung auch mal was zur Abwechslung erfrischendes. 
Um hier auch nicht mit der Zeit zu gehen würde ich tatsächlich hier auf die JavaFX Libary setzen. Diese war mal Bestandteil von der JDK aber seit Version 8 - *ich glaube aber weiß nicht genau* nicht mehr. Vorteile hier ist die native Unterstützung von CSS, hat eigebaute Charts, ein reiches Plugin-Ecosystem, ist flexibler im Layout. 
Einziger Nachteil ist das es ein Maven/Gradle build System benötigt, naja und man "muss sich ein arbeiten". Was ich genauso in ABT und swing machen müsste.
Ich hab mich vorher noch nicht so mit java build Systemen beschäftigt. Habe aber gestern doch recht zügig ein minimal config für gradle aufgesetzt. Gefällt mir persönlich besser als die XML artigen configs von Maven. Außerdem finde ich die Portabilität besser und man kann sowieso auch alle maven repositories verwenden. Sehe ich in dem fall einfach als Vorteil.

Qualitätssicherung
Wirtschaftlichkeit

|**Woche**|**Fokus**|**Hauptaufgaben**|
|---|---|---|
|**Woche 1**|**Planung & Setup**|Anforderungsanalyse, Architekturdesign (Klassendiagramm), Einarbeitung in die ASM-Bibliothek, Projektstruktur aufsetzen.|
|**Woche 2**|**Kernentwicklung**|Implementierung des File-Loaders, Einbindung des ASM-ClassVisitors, Extraktion von Metadaten (Klassenname, Felder).|
|**Woche 3**|**Analyse-Logik**|Implementierung der Methoden-Analyse und des Opcode-Counters, Logik für die statistische Auswertung.|
|**Woche 4**|**Finish & Doku**|UI-Feinschliff (CLI oder einfaches GUI), Testing (Unit Tests), Erstellung der Projektdokumentation.|

### Zeitplanung: Java-Bytecodeanalyzer (100 Stunden)

#### 1. Analyse (12 Stunden)

- **Ist-Analyse & Problemstellung (2h):** Untersuchung des Status Quo und Definition der Ziele.
    
- **Anforderungsanalyse (5h):** Erstellung eines Lastenhefts (Funktionale/Nicht-funktionale Anforderungen).
    
- **Technologie-Recherche (5h):** Vergleich von Bibliotheken (ASM, Javassist, ByteBuddy) und Auswahl des Stacks.
    

#### 2. Entwurf (18 Stunden)

- **Architekturdesign (6h):** Festlegung der Paketstruktur und Anwendung des Visitor-Patterns.
    
- **Klassendiagramm & Logik-Entwurf (8h):** Modellierung der Kernklassen und des Datenflusses.
    
- **UI-Konzept (4h):** Entwurf der Konsolenausgabe oder der Benutzeroberfläche.
    

#### 3. Implementierung und Einführung (50 Stunden)

- **Projekt-Setup & Grundgerüst (5h):** Maven/Gradle Konfiguration, Git-Repository, Basis-Klassen.
    
- **Kern-Logik: Bytecode-Parsing (15h):** Implementierung der Visitor-Klassen zum Einlesen der `.class`-Dateien.
    
- **Analyse-Funktionen (15h):** Entwicklung der Metriken (Opcode-Zähler, Klassenhierarchie-Extraktion).
    
- **User Interface & Reporting (8h):** Programmierung der Ausgabe-Schnittstelle (CLI/Datei-Export).
    
- **Testphase & Fehlerbehebung (7h):** Unit-Tests mit JUnit und Bugfixing.
    

#### 4. Dokumentation (20 Stunden)

- **Technische Projektdokumentation (12h):** Ausformulierung des Prozessberichts, Architekturbeschreibung.
    
- **Anwenderhandbuch (4h):** Erstellung einer Anleitung zur Installation und Nutzung.
    
- **Projektabschluss & Reflexion (4h):** Fazit, Soll-Ist-Vergleich und Lessons Learned.