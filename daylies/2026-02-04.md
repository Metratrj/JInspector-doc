Ganz simpel runtergebrochen: Ich glaube, ich möchte nochmal ändern, wie wir die `.class`-Dateien einlesen. Aktuell nehmen wir einen Pfad und sammeln mit dem `FileWalker` rekursiv alle Pfade, die mit `.class` enden.

Dann laden wir für jeden Pfad die Datei, außer sie heißt `module-info.class` -> Wir sollten auch `package-info.class`-Dateien fürs Erste skippen.

Dann parsen wir die Datei in dieser Reihenfolge:

- `classFile.parseMagic(in);`
    
- `classFile.parseVersion(in);`
    
- `classFile.parseConstantPool(in);`
    
- ...
    

Wir lesen also folgende Werte aus: `magic`, `minorVersion`, `constantPool`, `fields`, `attributes` etc.

Man beachte, dass wir dabei aber keine Verbindungen herstellen, keine Logik, nur reines Lesen.

Dann wird aus dem Geparsten ein Report generiert, das heißt, wir holen Daten aus dem `constantPool`. Der dazugehörige Code sieht folgendermaßen aus:

_(Code Block hier einfügen - siehe Option 1 für saubere Formatierung)_

Dann erst die nächste Datei.

Nachdem wir alle Reports haben, werden die Reports ausgegeben. Wenn ein `MethodReport` das Code-Attribut hat, wird hier erst der Bytecode analysiert.

Wie man sehen kann, ist das Chaos und das Produkt von planungslosem Coden.

```Java
private ClassReport generateReport(ClassFile cf) {  
        // Resolve Class Name  
        String className = resolveClassName(cf, cf.getThisClass());  
        String superName = resolveClassName(cf, cf.getSuperClass());  
          
        Set<String> classFlags = AccessFlagUtils.extract(cf.getAccessFlags()).stream()  
                .map(Enum::name).collect(Collectors.toSet());  
  
        // Methods  
        List<MethodReport> methods = new ArrayList<>();  
        if (cf.getMethods() != null) {  
            for (method_info m : cf.getMethods()) {  
                String name = resolveUtf8(cf, m.getNameIndex());  
                String desc = resolveUtf8(cf, m.getDescriptionIndex());  
                Set<String> mFlags = AccessFlagUtils.extractForMethod(m.getAccessFlags()).stream()  
                        .map(Enum::name).collect(Collectors.toSet());  
  
                Set<AttributeReport> attributes = new HashSet<>();  
                attributes = Arrays.stream(m.getAttributes()).map(attribute_info -> {  
                    String attribute_name = resolveUtf8(cf, attribute_info.getAttribute_name_index());  
                    return new AttributeReport(attribute_name, attribute_info.getAttribute_length(), attribute_info.getInfo());  
                }).collect(Collectors.toSet());  
  
                for (attribute_info a: m.getAttributes()) {  
                    String attribute_name = resolveUtf8(cf, a.getAttribute_name_index());  
                    System.out.println("Attribute Name" + attribute_name);  
//                    if (attribute_name.equals("Code")) {  
//                        try (DataInputStream inputStream = new DataInputStream(new ByteArrayInputStream(a.getInfo()))) {  
//                            int    maxStack   = inputStream.readUnsignedShort();  
//                            int    maxLocals  = inputStream.readUnsignedShort();  
//                            int    codeLength = inputStream.readInt();  
//                            byte[] code       = new byte[codeLength];  
//                            inputStream.readFully(code);  
//                            int exception_table_length = inputStream.readUnsignedShort();  
//                            for (int i = 0; i < exception_table_length; i++) {  
//                                int start_pc   = inputStream.readUnsignedShort();  
//                                int end_pc     = inputStream.readUnsignedShort();  
//                                int handler_pc = inputStream.readUnsignedShort();  
//                                int catch_type = inputStream.readUnsignedShort();  
//                            }  
//                            int attributes_count = inputStream.readUnsignedShort();  
//                            for (int i = 0; i < attributes_count; i++) {  
//                                int    attribute_name_index = inputStream.readUnsignedShort();  
//                                int    attribute_length     = inputStream.readInt();  
//                                byte[] info                 = new byte[attribute_length];  
//                                inputStream.readFully(info);  
//                            }  
//  
//                        } catch (Exception e) {  
//                            throw new RuntimeException(e);  
//                        }  
//                    }  
                }  
  
                methods.add(new MethodReport(name, desc, mFlags, attributes));  
            }  
        }  
  
        // Fields  
        List<FieldReport> fields = new ArrayList<>();  
        if (cf.getFields() != null) {  
            for (field_info f : cf.getFields()) {  
                String name = resolveUtf8(cf, f.getName_index());  
                Set<String> fFlags = AccessFlagUtils.extractForField(f.getAccess_flags()).stream()  
                        .map(Enum::name).collect(Collectors.toSet());  
                fields.add(new FieldReport(name, fFlags));  
            }  
        }  
  
        return new ClassReport(className, superName, classFlags, methods, fields);  
    }  
  
    private String resolveClassName(ClassFile cf, int index) {  
        if (index == 0) return "java/lang/Object"; // or null  
        var classInfo = cf.getConstantPoolItem(index, CONSTANT_Class_info.class);  
        if (classInfo != null) {  
            return resolveUtf8(cf, classInfo.name_index);  
        }  
        return "UnknownClass#" + index;  
    }  
  
    private String resolveUtf8(ClassFile cf, int index) {  
        var utf8Info = cf.getConstantPoolItem(index, CONSTANT_Utf8_info.class);  
        return utf8Info != null ? utf8Info.getValue() : "???";  
    }
```



---
**Thema: Refactoring des `.class`-Imports**

Ganz simpel runtergebrochen: Ich plane, den Einleseprozess der `.class`-Dateien zu überarbeiten.

Aktueller Ansatz: Wir nehmen einen Pfad und sammeln mit dem `FileWalker` rekursiv alle Pfade, die auf `.class` enden.

**1. Filterung**

Wir laden jede gefundene Datei, außer:

- `module-info.class`
    
- `package-info.class` (sollten wir fürs Erste auch überspringen)
    

**2. Parsing (Reihenfolge)**

Wir parsen die Datei streng sequenziell:

- `classFile.parseMagic(in);`
    
- `classFile.parseVersion(in);`
    
- `classFile.parseConstantPool(in);`
    
- `classFile.parseClassInfo(in);`
    
- ... (Interfaces, Fields, Methods, Attributes)
    

Wir lesen also nur die reinen Werte (`magic`, `versions`, `constantPool`, `fields`, `methods` etc.) in ein `ClassFile`-Objekt ein.

_Wichtig:_ Hierbei werden noch keine logischen Verbindungen hergestellt, es ist reines Einlesen („Dumb Parsing“).

**3. Report-Generierung**

Aus dem geparsten `ClassFile` wird ein `ClassReport` generiert. Hierbei lösen wir Referenzen aus dem `constantPool` auf. Der Code sieht in etwa so aus:

Java

```
private ClassReport generateReport(ClassFile cf) {
    // 1. Resolve Class Names
    String className = resolveClassName(cf, cf.getThisClass());
    String superName = resolveClassName(cf, cf.getSuperClass());
    
    Set<String> classFlags = AccessFlagUtils.extract(cf.getAccessFlags()).stream()
            .map(Enum::name).collect(Collectors.toSet());

    // 2. Process Methods
    List<MethodReport> methods = new ArrayList<>();
    if (cf.getMethods() != null) {
        for (method_info m : cf.getMethods()) {
            String name = resolveUtf8(cf, m.getNameIndex());
            String desc = resolveUtf8(cf, m.getDescriptionIndex());
            
            // ... Flag extraction & Attribute resolution ...
            
            // HINWEIS: Bytecode-Analyse (Code-Attribut) ist hier auskommentiert/entfernt 
            // und wird erst später bei Bedarf durchgeführt.

            methods.add(new MethodReport(name, desc, mFlags, attributes));
        }
    }
    // ... Process Fields ...
    return new ClassReport(className, superName, classFlags, methods, fields);
}
```

**4. Ausgabe & Lazy Analysis**

Erst nachdem alle Reports erstellt wurden, werden sie ausgegeben. Wenn ein `MethodReport` ein Code-Attribut besitzt, wird _erst an dieser Stelle_ der Bytecode analysiert.

**Fazit:** Aktuell ist es noch Chaos – das klassische Produkt von planungslosem Coden.
