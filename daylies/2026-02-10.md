

Think of we have two very similar data structures. The first one is very closely the same representation of the oracle documentation.
The second data structure is a DOM-like representation of the ClassFile as the RootNode, with Interfaces, Field, Method, and AttributeNodes, that are linked to each other and have all information already resolved out of the constant pool.

Einstiegspunkt
- bootstrap what we can bootstrap
- get root path
- root path -> walks file tree
	  - parallel gather path and data
	  - return DataRecord(String path, byte[] data)


Now we do not need any open File Handles anymore all needed Data is in Memory
- for each DataRecord
- parse the header
- for each field ->
	- parse the header
	- parse the field attributes
	- visit Field
	- foreach attribute
		- parse header
		- parse data
		- visit Attribute
		- end Visit
	- end Visit Field
- for each interface
- for each method
	- parse the header
	- parse the method attributes
		- depending on its value either parse it and store
		- or store its start offset in local variable
	- call visitMethod
	- for complex attributes wich where not parsed previous parse them and visit them at the same time: parse one part, visit it, parse next part visit it
	- for the special case of the code attribute
	- find the labels and store them
	- look for labels in code, exception handler, line number, local variable tables
	- if there is a stack map table parse the first frame
	- parse the instructions
		- if there is a stack map frame for this offset, call visitFrame, parse next frame
		- if there is a label, call visitLabel
		- if there is a line number entry for this offset, call visitLineNumber
	- visitAttribute
	- visitMaxs
- parse the class attributes


